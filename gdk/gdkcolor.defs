/* gdkcolor.defs
 *
 * Copyright 2024 Matthias Clasen
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

/* Note that this header is shared between the color state implementation
 * and tests, and must not include other headers.
 */

/* This file can be included either from C or from glsl.
 *
 * You need to define either COLOR_IN_C or COLOR_IN_GLSL to pick the syntax.
 *
 * Some other macros can be defined to determine what parts to include:
 * - NEED_CORE_TF (just srgb and pq)
 * - NEED_OTHER_TF (the remaining transfer functions)
 * - NEED_CORE_MATRICES (just srgb <> rec2020)
 * - NEED_OTHER_MATRICES (the abc <> xyz matrices)
 */

#if !defined(COLOR_IN_C) && !defined(COLOR_IN_GLSL)
#define COLOR_IN_C
#endif

#if !defined(NEED_CORE_TF) && !defined(NEED_OTHER_TF)
#define NEED_CORE_TF
#define NEED_OTHER_TF
#endif

#if !defined(NEED_CORE_MATRICES) && !defined(NEED_OTHER_MATRICES)
#define NEED_CORE_MATRICES
#define NEED_OTHER_MATRICES
#endif

#if defined(COLOR_IN_C)

#define TRANSFER_FUNCTION(name) static inline float name (float v)

#define MATRIX(name, m00, m01, m02, m10, m11, m12, m20, m21, m22) \
static const float name[3][3] = { \
  { m00, m01, m02 }, \
  { m10, m11, m12 }, \
  { m20, m21, m22 }, \
};

#define max(a,b) MAX(a,b)

#else

#define TRANSFER_FUNCTION(name) float name (float v)

#define MATRIX(name, m00, m01, m02, m10, m11, m12, m20, m21, m22) \
const mat3 name = mat3( \
 m00, m10, m20, \
 m01, m11, m21, \
 m02, m12, m22);

#endif

#if defined(NEED_CORE_TF) && !defined(HAVE_CORE_TF)
#define HAVE_CORE_TF

TRANSFER_FUNCTION(srgb_oetf)
{
  if (v > 0.0031308)
    return 1.055 * pow (v, 1.0 / 2.4) - 0.055;
  else
    return 12.92 * v;
}

TRANSFER_FUNCTION(srgb_eotf)
{
  if (v >= 0.04045)
    return pow (((v + 0.055) / (1.0 + 0.055)), 2.4);
  else
    return v / 12.92;
}

TRANSFER_FUNCTION(pq_eotf)
{
  float ninv = 16384.0 / 2610.0;
  float minv = 32.0 / 2523.0;
  float c1 = 3424.0 / 4096.0;
  float c2 = 2413.0 / 128.0;
  float c3 = 2392.0 / 128.0;

  float x = pow (max ((pow (v, minv) - c1), 0) / (c2 - (c3 * (pow (v, minv)))), ninv);

  return x * 10000.0 / 203.0;
}

TRANSFER_FUNCTION(pq_oetf)
{
  float x = v * 203.0 / 10000.0;
  float n = 2610.0 / 16384.0;
  float m = 2523.0 / 32.0;
  float c1 = 3424.0 / 4096.0;
  float c2 = 2413.0 / 128.0;
  float c3 = 2392.0 / 128.0;

  return pow (((c1 + (c2 * pow (x, n))) / (1 + (c3 * pow (x, n)))), m);
}

#endif
#if defined(NEED_OTHER_TF) && !defined(HAVE_OTHER_TF)
#define HAVE_OTHER_TF

TRANSFER_FUNCTION(bt709_eotf)
{
  const float a = 1.099;
  const float d = 0.0812;

  if (v < d)
    return  v / 4.5;
  else
    return pow ((v + (a - 1.0)) / a, 1.0 / 0.45);
}

TRANSFER_FUNCTION(bt709_oetf)
{
  const float a = 1.099;
  const float b = 0.018;

  if (v < b)
    return v * 4.5;
  else
    return a * pow (v, 0.45) - (a - 1.0);
}

TRANSFER_FUNCTION(hlg_eotf)
{
  const float a = 0.17883277;
  const float b = 0.28466892;
  const float c = 0.55991073;

  if (v <= 0.5)
    return (v * v) / 3.0;
  else
    return exp (((v - c) / a) + b) / 12.0;
}

TRANSFER_FUNCTION(hlg_oetf)
{
  const float a = 0.17883277;
  const float b = 0.28466892;
  const float c = 0.55991073;

  if (v <= 1.0 / 12.0)
    return sqrt (3.0 * v);
  else
    return a * log (12.0 * v - b) + c;
}

#endif

/* See http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 * for how to derive the abc_to_xyz matrices from chromaticity coordinates.
 */

#if defined(NEED_CORE_MATRICES) && !defined(HAVE_CORE_MATRICES)
#define HAVE_CORE_MATRICES

/* premultiplied matrices for default conversions */

MATRIX(rec2020_to_srgb,
  1.660227, -0.587548, -0.072838,
 -0.124553,  1.132926, -0.008350,
 -0.018155, -0.100603,  1.118998)

MATRIX(srgb_to_rec2020,
  0.627504, 0.329275, 0.043303,
  0.069108, 0.919519, 0.011360,
  0.016394, 0.088011, 0.895380)

#endif
#if defined(NEED_OTHER_MATRICES) && !defined(HAVE_OTHER_MATRICES)
#define HAVE_OTHER_MATRICES

MATRIX(srgb_to_xyz,
  0.4124564,  0.3575761,  0.1804375,
  0.2126729,  0.7151522,  0.0721750,
  0.0193339,  0.1191920,  0.9503041)

MATRIX(xyz_to_srgb,
  3.2404542, -1.5371385, -0.4985314,
 -0.9692660,  1.8760108,  0.0415560,
  0.0556434, -0.2040259,  1.0572252)

MATRIX(rec2020_to_xyz,
  0.6369580,  0.1446169,  0.1688810,
  0.2627002,  0.6779981,  0.0593017,
  0.0000000,  0.0280727,  1.0609851)

MATRIX(xyz_to_rec2020,
  1.7166512, -0.3556708, -0.2533663,
 -0.6666844,  1.6164812,  0.0157685,
  0.0176399, -0.0427706,  0.9421031)

MATRIX(pal_to_xyz,
  0.4305538,  0.3415498,  0.1783523,
  0.2220043,  0.7066548,  0.0713409,
  0.0201822,  0.1295534,  0.9393222)

MATRIX(xyz_to_pal,
  3.0633611, -1.3933902, -0.4758237,
 -0.9692436,  1.8759675,  0.0415551,
  0.0678610, -0.2287993,  1.0690896)

MATRIX(ntsc_to_xyz,
  0.3935209,  0.3652581,  0.1916769,
  0.2123764,  0.7010599,  0.0865638,
  0.0187391,  0.1119339,  0.9583847)

MATRIX(xyz_to_ntsc,
  3.5060033, -1.7397907, -0.5440583,
 -1.0690476,  1.9777789,  0.0351714,
  0.0563066, -0.1969757,  1.0499523)

MATRIX(p3_to_xyz,
  0.4865709,  0.2656677,  0.1982173,
  0.2289746,  0.6917385,  0.0792869,
  0.0000000,  0.0451134,  1.0439444)

MATRIX(xyz_to_p3,
  2.4934969, -0.9313836, -0.4027108,
 -0.8294890,  1.7626641,  0.0236247,
  0.0358458, -0.0761724,  0.9568845)

#endif
